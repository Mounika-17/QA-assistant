deploy:
  name: Deploy to self-hosted (EC2)
  needs: build-and-push
  runs-on: [ self-hosted, linux, x64 ]

  steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set IMAGE env from build job output
      # Put the image string into GITHUB_ENV so subsequent steps see it reliably
      run: |
        echo "IMAGE=${{ needs.build-and-push.outputs.image }}" >> $GITHUB_ENV

    - name: Debug: show resolved image (will be masked for secrets if any)
      run: |
        echo "Resolved IMAGE => $IMAGE"
        # also show registry + repo so we can see where it's pulling from
        echo "Registry => ${{ steps.login-ecr.outputs.registry }}"
        echo "Repo => ${{ secrets.ECR_REPO }}"

    - name: Pull & Run Docker image on self-hosted runner
      run: |
        # fail fast if IMAGE is empty
        if [ -z "$IMAGE" ]; then
          echo "ERROR: IMAGE is empty. Aborting."
          exit 1
        fi

        docker pull "$IMAGE"

        if docker ps -a --format '{{.Names}}' | grep -q '^myapp$'; then
          docker rm -f myapp || true
        fi

        docker run -d --name myapp \
          -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
          -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
          -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
          -e GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}" \
          -p 8080:8080 \
          "$IMAGE"
